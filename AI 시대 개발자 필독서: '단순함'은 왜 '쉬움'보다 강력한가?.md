# AI 시대 개발자 필독서: '단순함'은 왜 '쉬움'보다 강력한가?

Copilot, Cursor, Claude와 같은 AI 코딩 도구들은 개발 속도를 혁명적으로 바꾸고 있습니다. 며칠 걸리던 작업이 몇 시간 만에 끝나고, 몇 년간 엄두도 못 내던 리팩토링이 마침내 시작되었습니다. 그러나 이 눈부신 속도 뒤에는 어두운 그림자가 숨어 있습니다. 넷플릭스의 시니어 엔지니어 제이크 네이션스(Jake Nations)는 이 문제를 다음과 같은 충격적인 고백으로 요약합니다.

"저는 제가 이해하지 못하는 코드를 배포했고, 여러분도 마찬가지일 거라고 확신합니다."

네이션스의 고백은 일부의 이야기가 아닙니다. 업계 전반의 스탠드업과 코드 리뷰에서 조용히 퍼져나가는 현실입니다. 우리는 배우는 속도보다 더 빨리 배포하고 있으며, 이것이야말로 가장 교활한 형태의 기술 부채입니다. AI가 제공하는 경이로운 속도는 개발자들에게서 시스템을 깊이 이해할 시간을 빼앗아 가고 있습니다. 코드는 폭발적으로 쌓이지만, 정작 그 코드를 만든 개발자조차 시스템의 동작 원리를 완전히 파악하지 못하는 '지식 격차'가 벌어지는 것입니다. 이것이 바로 AI 시대의 역설입니다.

이 문서는 이러한 문제를 해결하기 위한 핵심 열쇠로써 '단순함(simplicity)'과 '쉬움(easiness)'의 결정적 차이를 탐구합니다. 이 두 개념을 명확히 이해함으로써, 우리는 AI라는 강력한 도구를 지배하고 더 견고하고 유지보수하기 좋은 소프트웨어를 만드는 지혜를 얻게 될 것입니다.

이 역설을 해체하기 위해, 우리는 먼저 그것을 정의하는 어휘부터 마스터해야 합니다. 문제는 개발자들이 끊임없이 혼동하는 두 단어, '쉬움'과 '단순함'에서 시작됩니다.

1. '쉬움'과 '단순함'의 결정적 차이

클로저(Clojure) 언어의 창시자 리치 히키(Rich Hickey)는 '단순함'과 '쉬움'이 완전히 다른 개념이라고 강조했습니다. 제이크 네이션스는 이 구분이 오늘날 AI 시대를 살아가는 개발자에게 그 어느 때보다 중요하다고 말합니다. 두 개념의 차이는 다음과 같이 명확하게 정리할 수 있습니다.

구분	쉬움 (Easiness)	단순함 (Simplicity)
정의 (Definition)	"손에 잡히는 것"<br>익숙하거나 당장 사용하기 편한 것을 의미합니다. 스택오버플로우 코드를 복사해 붙여넣거나, 명령어 한 줄로 패키지를 설치하는 행위가 여기에 해당합니다.	"얽힌 게 없는 것"<br>개념적으로 얽힘(entanglement)이 없는 상태를 의미합니다. 시스템의 각 부분이 정확히 하나의 역할만 수행하고 다른 부분과 복잡하게 엮여 있지 않은 상태입니다.
초점 (Focus)	접근성 (Accessibility)<br>얼마나 빨리 시작하고 적용할 수 있는가에 초점을 맞춥니다.	구조 (Structure)<br>시스템의 근본적인 설계와 구성 요소 간의 관계에 초점을 맞춥니다.
의미 (Meaning)	"빨리 뭔가 추가할 수 있다"<br>당장의 개발 속도와 즉각적인 결과물을 의미합니다.	"내가 만든 걸 이해할 수 있다"<br>장기적인 명확성과 시스템에 대한 완전한 이해를 의미합니다.

아키텍처의 관점에서 말하자면, '쉬움'은 전략적 부채를 누적시키는 전술적 선택입니다. 반면 '단순함'은 장기적으로 속도와 회복탄력성이라는 배당금을 지급하는 전략적 투자입니다. 근본적으로 '쉬움'은 미래의 복잡성을 담보로 현재의 속도를 얻는 선택인 반면, '단순함'은 초반에 더 많은 고민과 설계를 요구하지만 장기적으로는 비교할 수 없는 명확성과 안정성을 제공합니다.

이 구분이 명확해 보임에도 불구하고, 우리의 새로운 AI 도구들은 거의 중력과 같은 강력한 힘으로 우리를 '쉬운 길'로 끌어당깁니다. 종종 우리가 알아채지도 못하는 사이에 말입니다.

2. '쉬운 길'의 함정: AI는 어떻게 복잡성을 증폭시키는가

AI 코딩 도구는 궁극의 "쉬운 길" 버튼과 같습니다. 질문을 던지면 몇 초 만에 코드가 쏟아져 나오니, 개발자는 "잠깐, 이게 맞는 설계인가?"라고 멈춰서 고민할 틈을 잃어버립니다.

제이크 네이션스는 앱에 여러 로그인 제공자(구글, 카카오 등)를 추가하는 구체적인 예시를 듭니다. 개발자는 AI에게 "구글 로그인 추가해줘", "카카오도 추가해줘" 같은 단순 요청을 반복합니다. 몇 번의 요청이 오가면 세션 관리가 꼬이고 예상치 못한 에러가 발생하기 시작합니다. 개발자는 "에러 고쳐줘", "아니 그게 아니라..."와 같은 지시를 반복하며, 결국 코드베이스에는 중간에 버려진 시도와 임시방편 코드의 잔해가 뒤섞이게 됩니다.

이 과정에서 AI는 결코 먼저 경고하지 않습니다.

"AI는 '이 설계 별로인데요' 같은 말 안 해요. 시키는 대로 만들 뿐이에요."

소프트웨어 공학의 대가 프레드 브룩스(Fred Brooks)는 복잡성을 두 가지로 나누었습니다.

1. 본질적 복잡성 (Essential Complexity): 해결하려는 문제 자체가 본질적으로 가진 어려움입니다.
2. 우발적 복잡성 (Accidental Complexity): 문제를 해결하는 과정에서 우리가 스스로 추가한 불필요한 복잡성입니다. (임시방편 코드, 잘못된 설계, 기술 부채)

AI는 이 두 가지를 전혀 구분하지 못합니다. 5년 전에 급하게 만든 임시방편 코드나 잘 설계된 코드 모두 AI에게는 똑같은 "패턴"일 뿐입니다. 그 결과, AI는 기존의 기술 부채를 학습하고 정당화합니다. 잘못 설계된 임시 코드를 유효한 선례로 취급하고, 이를 기반으로 새로운 기능을 구축하여 우발적 복잡성을 증폭시킵니다. AI는 당신의 우발적 복잡성을 코드베이스 안에서 자가 복제하는 바이러스로 만듭니다.

만약 AI가 우리의 지시를 증폭시키는 장치라면, 해결책은 더 나은 AI가 아니라 근본적으로 더 나은 인간의 지시입니다. 이제 초점은 코딩 행위에서 생각하는 행위로 옮겨가야 합니다.

3. 복잡성 극복하기: AI를 지배하는 개발자의 생각법

프레드 브룩스는 소프트웨어 개발에서 가장 어려운 부분은 코드를 타이핑하는 기계적 행위가 아니라고 단언했습니다.

"진짜 어려운 건 '뭘 만들지?', '어떻게 설계하지?' 이런 물음들이에요."

이러한 인지적 작업을 체계화하고 AI를 효과적으로 이끌기 위해, 제이크 네이션스는 "컨텍스트 압축 (Context Compression)" 이라는 접근법을 사용합니다. 이는 AI 엔지니어링 커뮤니티에서 덱스 호디(Dex Horthy)와 같은 선구자들이 개척하고 있는 "리서치-플래닝-구현 (Research, Plan, Implement, RPI)" 또는 "고급 컨텍스트 엔지니어링"이라 불리는 광범위한 방법론의 실용적인 적용 사례입니다. 이는 AI에게 생각을 맡기는 것이 아니라, 인간의 깊은 생각을 통해 AI의 실행력을 극대화하는 전략입니다.

1. 리서치 (Research)
  * 목표: AI에게 작업을 지시하기 전, 관련된 모든 맥락을 수집해 검증된 단일 진실 공급원(Source of Truth)을 만듭니다.
  * 방법: 아키텍처 다이어그램, 기존 설계 문서, 심지어 슬랙 대화까지 모든 정보를 모으고, 이를 바탕으로 AI를 활용해 코드베이스를 분석합니다. 이 과정에서 얻은 정보를 사람이 직접 검증하여 최종 리서치 문서를 완성합니다. 이 단계에서 실수를 잡으면 나중에 큰 사고를 막을 수 있습니다.
2. 플래닝 (Planning)
  * 목표: 검증된 리서치 문서를 바탕으로, 신입 개발자도 따라 할 수 있을 만큼 상세하고 명확한 단계별 구현 계획을 수립합니다.
  * 방법: 코드 구조, 데이터 흐름, 테스트 방안 등을 구체적으로 명시합니다. 바로 이 단계에서 시스템의 '단순함'을 확보하기 위한 핵심적인 설계 결정이 인간에 의해 이루어집니다.
3. 구현 (Implementation)
  * 목표: 명확하게 정의된 계획을 AI가 오류 없이 실행하도록 합니다.
  * 방법: 잘 짜인 계획(명세)이 있으면, AI는 50번의 대화를 거치며 길을 잃는 대신 단 몇 번의 집중된 작업만으로 결과물을 만들어냅니다. 인간의 리서치와 계획이 AI의 기계적인 작업 속도를 더욱 빠르고 정확하게 만드는 것입니다.

하지만 이 3단계 접근법이 마법의 총알은 아닙니다. 네이션스는 자신의 대규모 리팩토링 프로젝트에서 이 방법이 효과를 발휘하기 전에 반드시 거쳐야 했던 고통스러운 과정이 있었다고 고백합니다. 바로 직접 손으로 해보는 것이었습니다.

"AI 없이 코드를 읽고, 의존성을 파악하고, 직접 바꿔보면서 뭐가 터지는지 확인했어요... 그제서야 숨겨진 규칙들이 보이기 시작했거든요."

결국 AI 시대에도 시스템에 대한 깊은 인간의 이해는 대체 불가능하며, 이는 종종 어려운 수작업을 통해 얻어지는 통찰입니다. 이 경험이 있어야만 AI를 올바른 방향으로 이끌 효과적인 계획을 세울 수 있습니다.

이처럼 AI를 이끌기 위한 인간 중심의 절제된 접근 방식은 개발자의 역할이 근본적으로 진화하고 있음을 시사합니다. 코드를 작성하는 것에서 결과를 설계하는 것으로 말입니다.

4. 결론: 코더를 넘어 '프로덕트 엔지니어'로

세계적인 AI 석학 앤드류 응(Andrew Ng) 교수는 AI 시대의 새로운 병목 현상을 지적했습니다. 소프트웨어 개발의 가장 큰 장애물은 더 이상 코드 구현 속도가 아니라, "무엇을 만들 것인가?" 라는 의사결정의 질입니다.

구현 속도가 거의 무한에 가까워지면서, 이 병목 현상은 예상치 못한 곳에서 나타나고 있습니다. 바로 프로젝트 관리입니다. AI로 개발 속도는 폭발적으로 증가했지만, Jira 같은 전통적인 관리 도구의 행정적 오버헤드, 즉 '일을 위한 일(Work about Work)'이 이제 팀의 속도를 저해하는 주된 장애물이 되고 있습니다. 앤드류 응의 통찰이 고통스러울 만큼 현실적으로 증명되는 순간입니다.

AI가 코드 작성을 대부분 책임지게 될 미래에 가장 성공하는 개발자는 코드를 가장 많이 생성하는 사람이 아닐 것입니다. 대신, 자신이 무엇을 만들고 있는지 깊이 이해하고, 시스템의 경계를 볼 수 있으며(see the boundaries), 올바른 설계적 판단을 내리는 사람이 될 것입니다.

이는 앤드류 응 교수가 말하는 '프로덕트 엔지니어(Product Engineer)' 의 모습과 같습니다. 단순한 코드 구현 능력을 넘어, 제품의 비전과 사용자 공감 능력을 통합한 개발자만이 압도적인 경쟁력을 갖게 될 것입니다.

따라서 우리 세대 엔지니어들에게 주어진 결정적인 도전 과제는 얼마나 빨리 코드를 생성할 수 있느냐가 아니라, 우리가 만드는 시스템에 대한 명확성과 주인의식을 어떻게 유지할 것인가입니다. 우리는 제이크 네이션스의 마지막, 뇌리를 떠나지 않는 질문에 답해야 합니다.

"AI가 코드 대부분을 쓸 때, 우리가 여전히 우리 시스템을 이해하고 있을까?"
